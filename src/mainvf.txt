#include "encoder.h"
#include "motor.h"
#include "Arduino.h"
#include "ultrasound.h"
#include "line_tracker.h"

#include <ArduinoJson.h>
#include <HardwareSerial.h>
#include <AceWire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "HX711.h"
HX711 scale;
#define calibration_factor -800

#define SCREEN_WIDTH 128 // Largeur de l'écran OLED en pixels
#define SCREEN_HEIGHT 64 // Hauteur de l'écran OLED en pixels
#define OLED_RESET -1    // Nécessaire pour les écrans OLED qui ne disposent pas d'un RST dédié
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
HardwareSerial SerialESP(0);

const int DOUT= 5;
const int CLK= 4;

int default_speed = 90;
int speedA = 0;
int speedB = 0;
bool isBusy = false;
bool dir_changed = false;
bool detect = false;
int n_loop = 0;


// int move = 60;

int threshold = 3800;

int pos = 0;
int dest = 0;

int weight=0;
int capteurs[5]={0,0,0,0,0};
int capteurs2[5]={0,0,0,0,0};

int n_mem = 9;
int memory[9][5]={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}};
int l_mem[5]={0,0,0,0,0};
int ligne_choisie[5]={0,0,0,0,0};


int ponderation_g[5] = {-3,-1,0,1,3}; // Proportionnel
int ponderation_d[5] = {3,1,0,-1,-3}; // Proportionnel
int tab_time[9]={6,5,-3,2,-1,1,-1,1,-1};


String getBotstate() {
  //String botstate[4] = {"idle", "busy", "error","off"};
  if (!isBusy) {
    return "idle";
  }
  else if (isBusy) {
    return "busy";
  }
}

void sendData(){
  DynamicJsonDocument state(1024);
  state["botstate"] = getBotstate();
  state["batterystate"] = 85;
  state["location"] = pos;
  state["weight"] = weight;
  String jsonString;
  serializeJson(state, jsonString);
  Serial.println(jsonString);
}

void listenDest(){
  if (Serial.available()>0){
    dest = Serial.parseInt();// Lire les données entrantes et les convertir en valeur numérique,si serial.read() on aura le numero mais en ascii
  }
}

void acquisition(){
    capteurs[0]=Left2();
    capteurs[1]=Left1();
    capteurs[2]=Center();
    capteurs[3]=Right1();
    capteurs[4]=Right2();
    capteurs2[0]=capteurs[0];
    capteurs2[1]=capteurs[1];
    capteurs2[2]=capteurs[2];
    capteurs2[3]=capteurs[3];
    capteurs2[4]=capteurs[4];
}

void keep_memory(){
    for (int i=0; i<(n_mem); i++){
        for (int j=0; j<5;j++){
            memory[n_mem-i][j] = memory[n_mem-1-i][j];
        }
    }
    for (int i=0;i<5;i++){
        if(capteurs[i]<threshold){
            memory[0][i] = 1;
        }
        else{
            memory[0][i] = 0;
        }
    }
}

void clean_mem(){
    for(int i=0;i<n_mem;i++){
        for(int j=0;j<5;j++){
            memory[i][j]=0;
        }
    }
}

void displayAll(){ 
    display.clearDisplay();
    display.setCursor(0,0);
    display.print("Poids: ");
    display.print(weight);
    display.print(" g");
    display.setCursor(0,20);
    display.print("Pos: ");
    display.print(pos);
    display.setCursor(0,40);
    display.print("Dest: ");
    display.print(dest);
    display.setCursor(0,55);
    display.print(getBotstate());
    display.display();
}

void check_bureau(){
    if(memory[0][1]==1 && memory[0][2]==1 && memory[0][3]==1 && (memory[0][4]==1||memory[0][0]==1)){
        Serial.print("Nouveau bureau detecte \n");
        if(pos<dest){
            pos+=1;
        }
        else if(dest<pos){
            pos-=1;
        }
        detect = true;
        // sendData();
        // displayAll();
    }
}
   
void chose_line(int tab[9][5], int n){
    for(int i=0;i<5;i++){
        ligne_choisie[i]=tab[n][i];
    }
}

int cal_d(int tab[5]){
    int res = 0;
    for(int i=0;i<5;i++){
        res+=tab[i]*ponderation_d[i];
    }
    return res;
}

int cal_g(int tab[5]){
    int res = 0;
    for(int i=0;i<5;i++){
        res+=tab[i]*ponderation_g[i];
    }
    return res;
}

void calcul_reg(int tab[9][5]){
    // On prend chaque ligne 1 à 1...
    int tab0[5]={0,0,0,0,0};
    chose_line(tab,0);
    for(int i=0;i<5;i++){
        tab0[i]=ligne_choisie[i];
    }

    chose_line(tab,1);
    int tab1[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab1[i]=ligne_choisie[i];
    }

    chose_line(tab,2);
    int tab2[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab2[i]=ligne_choisie[i];
    }

    chose_line(tab,3);
    int tab3[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab3[i]=ligne_choisie[i];
    }
    chose_line(tab,4);
    int tab4[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab4[i]=ligne_choisie[i];
    }
    chose_line(tab,5);
    int tab5[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab5[i]=ligne_choisie[i];
    }
    chose_line(tab,6);
    int tab6[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab6[i]=ligne_choisie[i];
    }
    chose_line(tab,7);
    int tab7[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab7[i]=ligne_choisie[i];
    }
    chose_line(tab,8);
    int tab8[5]={0,0,0,0,0};
    for(int i=0;i<5;i++){
        tab8[i]=ligne_choisie[i];
    }
    // ... Puis on calcule la vitesse régulée
    speedA = default_speed+tab_time[0]*cal_g(tab0)+tab_time[1]*cal_g(tab1)+tab_time[2]*cal_g(tab2)+tab_time[3]*cal_g(tab3)+tab_time[4]*cal_g(tab4)+tab_time[5]*cal_g(tab5)+tab_time[6]*cal_g(tab6)+tab_time[7]*cal_g(tab7)+tab_time[8]*cal_g(tab8);
    speedB = default_speed+tab_time[0]*cal_d(tab0)+tab_time[1]*cal_d(tab1)+tab_time[2]*cal_d(tab2)+tab_time[3]*cal_d(tab3)+tab_time[4]*cal_d(tab4)+tab_time[5]*cal_d(tab5)+tab_time[6]*cal_d(tab6)+tab_time[7]*cal_d(tab7)+tab_time[8]*cal_d(tab8);
    /* // PID classique impossible => il va faire des oscillations (supposition)
    integ+= Ki_Te*cal_g(tab0);
    inted+= Ki_Te*cal_d(tab0);
    speedA = default_speed+ Kp(cal_g(tab0)+integ+Kd/Te*(cal_g(tab0)-e0g));
    speedB = default_speed+ Kp(cal_d(tab0)+inted+Kd/Te*(cal_d(tab0)-e0d));
    e0g = cal_g(tab0);
    e0d = cal_d(tab0);
    */
}


void turn_left(){
    move_forward(0, speedB);
    double ticks_for_turn = 400;
    double  previous_ticks = Read_Right_ENC_CHAN_A();
    double  actual_ticks = Read_Right_ENC_CHAN_A();
    double ticks = 0;
   
   while (ticks < ticks_for_turn)
   {
    actual_ticks = Read_Right_ENC_CHAN_A();
    ticks = actual_ticks - previous_ticks;
    }
    stop_motors();
}

void turn_right(){
    move_forward(speedA, 0);
    double ticks_for_turn = 400;
    double previous_ticks = Read_Left_ENC_CHAN_A();
    double actual_ticks = Read_Left_ENC_CHAN_A();
    double ticks = 0;
    
    while (ticks < ticks_for_turn)
    {
        actual_ticks = Read_Left_ENC_CHAN_A();
        ticks = actual_ticks - previous_ticks;
        }
    stop_motors();
}

void change_direction(){
    move_backward(default_speed,default_speed);
    double ticks_for_turn = 465;
    double  previous_ticks = Read_Left_ENC_CHAN_A();
    double  actual_ticks = Read_Left_ENC_CHAN_A();
    double ticks = 0;

    while (ticks < ticks_for_turn){
    actual_ticks = Read_Left_ENC_CHAN_A();
    ticks = actual_ticks - previous_ticks;
    }
    stop_motors();
    clean_mem();
    dir_changed=!dir_changed;
}


void move_regulation(){
    if ( capteurs[0]>threshold && capteurs[1]>threshold && capteurs[2]>threshold && capteurs[3]>threshold && capteurs[4]>threshold){
        stop_motors();
        clean_mem();
    }
    else if (capteurs[0]<threshold && capteurs[1]>threshold && capteurs[2]>threshold && capteurs[3]>threshold && capteurs[4]<threshold){
        stop_motors();
        clean_mem();
    }
    // On a atteint la destination
    /*else if( capteurs[0]<threshold && capteurs[1]<threshold && capteurs[2]<threshold && capteurs[3]<threshold && capteurs[4]<threshold && pos == dest){
        stop_motors();
        send_notif();
    }
    //move left
    else if ( capteurs[0]<threshold && capteurs[1]<threshold && capteurs[2]<threshold && capteurs[3]>threshold && capteurs[4]>threshold){
        turn_left();
    }
    //move right
    else if ( capteurs[0]>threshold && capteurs[1]>threshold && capteurs[2]<threshold && capteurs[3]<threshold && capteurs[4]<threshold){
        turn_right();
    }*/
    else if (memory[0][0]==1 || memory[0][1]==1 || memory[0][2]==1 || memory[0][3]==1 || memory[0][4]==1){
        move_forward(speedA,speedB);
    }
    else{
        stop_motors();
        clean_mem();
    }
}


void move(){
    isBusy=true;
    sendData();
    displayAll();
    while((pos!=dest)){
        if (((dest<pos)&&(!dir_changed))||((dest>pos)&&(dir_changed))){
            change_direction();
            clean_mem();
        }
        switch_ultrasounds();
        if((read_ultrasound1()<30)||(read_ultrasound2()<30)){
            stop_motors();
            clean_mem();
        }
        else{
        acquisition();
        keep_memory();
        if (!detect){
            check_bureau();
            
        }
        else if(memory[0][0]==1 && memory[0][4]==1){
            detect=false;
        }
        calcul_reg(memory);      
        move_regulation();
        }
    }
    if (pos==dest){
        stop_motors();
        clean_mem();
        isBusy=false;
        //n_loop+=1;
    }
}

void weigh(){
    weight = scale.get_units(10);
}

void setup() {
    Serial.begin(115200);
    Init_Encoders();
    init_motors();
    init_untrasounds();  
    init_tracker();

    display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
    display.clearDisplay();
    display.setTextColor(WHITE);
    display.setTextSize(1);
    display.setCursor(0, 0);
    display.display();

    scale.begin(DOUT, CLK);
    scale.set_scale(450.0f);
    scale.tare();
    //sendData();



    // scale.set_gain(128);
    // scale.tare(); // Mise à zéro de la balance
    // //pinMode(buzzerPin, OUTPUT);
    // display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
    // display.clearDisplay();
    // display.setTextColor(WHITE);

//scale.set_scale(2280.0f); // Étalonnage de la HX711 pour obtenir les bonnes valeurs en grammes
//scale.set_scale(450.5F); // Étalonnage de la HX711 pour obtenir les bonnes valeurs en grammes
    // display.setCursor(0, 0);
    // display.print("Balance ESP32");
    // display.display();
}

void loop() {
    while((pos==dest)){
        stop_motors();
        sendData();
        listenDest();
        weigh();
        displayAll();
        //display.clearDisplay();
        //Serial.println(speedA);
        //sendData();// add delay
    }
    // delay(1000);
    if(pos!=dest){
        move();
        sendData();
    }


    // switch_ultrasounds();
    // if((read_ultrasound1()<30)||(read_ultrasound2()<30)){
    //     stop_motors();
    //     clean_mem();
    // }
    // else{
    //move();
    // }

//&&(capteurs[0]<threshold||capteurs[1]<threshold||capteurs[2]<threshold||capteurs[3]<threshold||capteurs[4]<threshold)


}